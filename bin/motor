#!/usr/bin/env python3

import codecs
import json
import math
import numpy as np
import os
import sys

LIBRARY_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../lib/ext"))

DATA_DEFAULTS = {
    "round": 3,
    "relation": "<=",
    "method": "maximize"
}

SENSITIVITY_KEYS = {
    "coeff": ["basic_variable", "activity", "dual_value", "obj_coef",    "range_from",  "range_till"],
    "bound": ["constraint",     "activity", "dual_value", "lower_bound", "upper_bound", "range_lower", "range_upper"]
}

INFINITY = 9e99

sys.path.append(LIBRARY_PATH)

import pymprog as pm

import swiglpk as glpk

from enum import StrEnum

class Status(StrEnum):
    optimal    = 'Solution is optimal'
    feasible   = 'Solution is feasible'
    infeasible = 'Solution is infeasible'
    nofeasible = 'Problem has no feasible solution'
    unbounded  = 'Problem has unbounded solution'
    undefined  = 'Solution is undefined'

    __glpk__ = {
        glpk.GLP_OPT    : 'optimal',
        glpk.GLP_FEAS   : 'feasible',
        glpk.GLP_INFEAS : 'infeasible',
        glpk.GLP_NOFEAS : 'nofeasible',
        glpk.GLP_UNBND  : 'unbounded',
        glpk.GLP_UNDEF  : 'undefined',
    }

    @classmethod
    def code(self, status):
        return self.__glpk__[status]

    @classmethod
    def desc(self, status):
        return self[self.code(status)]

    @classmethod
    def is_success(self, status):
        return status == glpk.GLP_OPT

def load(input):
    with open(input) as file:
        data = json.load(file)
    return data

def store(output, result):
    if output is None:
        try:
            print(json.dumps(result, indent=2, ensure_ascii=False))
        except IOError:
            pass
    else:
        with codecs.open(output, 'w', encoding='utf-8') as file:
            json.dump(result, file, indent=2, ensure_ascii=False)

class InvalidDataError(Exception):
    pass

def validate(data):
    if not data:
        raise InvalidDataError(f'Input data is empty')

    for required in ['variables', 'objective', 'constraints']:
        if required not in data:
            raise InvalidDataError(f'Missing field: {required}')

    method = data.get('method')
    match method:
        case 'maximize' | 'minimize' | None:
            pass
        case _:
            raise InvalidDataError(f'Invalid optimization method: {method}')

    required = 'coefficients'
    if required not in data['objective']:
        raise InvalidDataError(f'Missing field in objective: {required}')

    number_of_variables = len(data['variables'])
    if number_of_variables == 0:
        raise InvalidDataError(f'Empty variables')

    for name in data['variables']:
        if not isinstance(name, str):
            raise InvalidDataError('Variable name must be a string')

    def validate_coefficients(coefficients, where):
        if len(coefficients) != number_of_variables:
            raise InvalidDataError(f'Wrong number of coefficients at: {where}')
        for coefficient in coefficients:
            if not isinstance(coefficient, (int, float)):
                raise InvalidDataError(f'Non numeric coefficient at: {where}')

    validate_coefficients(data['objective']['coefficients'], 'objective')

    for i, constraint in enumerate(data['constraints']):
        for required in ['name', 'rhs', 'coefficients']:
            if required not in constraint:
                raise InvalidDataError(f'Error in constraint[{i}]: Missing field: {required}')

        if not isinstance(constraint['name'], str):
            raise InvalidDataError(f'Error in constraint[{i}]: Name must be a string')
        if not isinstance(constraint['rhs'], (int, float)):
            raise InvalidDataError(f'Error in constraint[{i}]: rhs value must be numeric')

        match constraint.get('relation'):
            case '<=' | '<' | '=' | '==' | '>' | '>=' | None:
                pass
            case _:
                raise InvalidDataError(f'Error in constraint[{i}]: unrecognized relation')

        validate_coefficients(constraint['coefficients'], f'constraint[{i}]')    

    return data

def invalid(error):
    return {
        "success": False,
        "status": {
            "code": "invalid",
            "desc": str(error),
        },
        "response": {},
        "request": {}
    }

def setup(data):
    variables = []
    for name in data['variables']:
        variables.append(pm.simplevar(name))

    objective = np.dot(variables, data['objective']['coefficients'])

    constraints = []
    for constraint_data in data['constraints']:
        match constraint_data.get('relation', DATA_DEFAULTS['relation']):
            case '<=':
                constraint = np.dot(variables, constraint_data['coefficients']) <= constraint_data['rhs']
            case '=' | '==':
                constraint = np.dot(variables, constraint_data['coefficients']) == constraint_data['rhs']
            case '<':
                constraint = np.dot(variables, constraint_data['coefficients']) < constraint_data['rhs']
            case '>=':
                constraint = np.dot(variables, constraint_data['coefficients']) >= constraint_data['rhs']
            case '>':
                constraint = np.dot(variables, constraint_data['coefficients']) > constraint_data['rhs']
        constraint.name = constraint_data['name']
        constraints.append(constraint)

    match data.get('method', DATA_DEFAULTS['method']):
        case 'maximize':
            pm.maximize(objective, data['objective']['name'])
        case 'minimize':
            pm.minimize(objective, data['objective']['name'])

def solve(data):
    pm.begin(data['name'])

    setup(data)

    glpk.glp_term_out(glpk.GLP_OFF)
    pm.solve()
    status = pm.status()

    solution     = pm.vobj()
    coeff, bound = pm.sensitivity()

    pm.end()

    ndigits = int(data.get('round', DATA_DEFAULTS['round']))

    def transfer(results, keys):
        results = [dict(zip(keys, item)) for item in results]
        for result in results:
            result[keys[0]] = True if result[keys[0]] == "*" else False
            for k in result.keys():
                if isinstance(result[k], float):
                    if math.isinf(result[k]) or math.fabs(result[k]) > INFINITY:
                        result[k] = INFINITY if result[k] > 0 else -INFINITY
                    else:
                        result[k] = round(result[k], ndigits)
        return results

    def with_product_ids(bound):
        constraints = data['constraints']
        for i, _ in enumerate(bound):
            bound[i]['product_id'] = constraints[i].get('product_id')
        return bound

    return {
        "success": Status.is_success(status),
        "status": {
            "code": Status.code(status),
            "description": Status.desc(status)
        },
        "response": {
            "solution": round(solution, ndigits),
            "sensitivity": {
                "coeff": transfer(coeff, SENSITIVITY_KEYS["coeff"]),
                "bound": with_product_ids(transfer(bound, SENSITIVITY_KEYS["bound"]))
            }
        },
        "request": data
    }

def main():
    narg = len(sys.argv)

    if narg == 1 or (sys.argv[1] == '-validate' and narg < 3):
        sys.exit("Input data required")

    validate_only = False

    if sys.argv[1] == '-validate':
        validate_only = True

        input = sys.argv[2]
        output = sys.argv[3] if narg > 3 else None
    else:
        input = sys.argv[1]
        output = sys.argv[2] if narg > 2 else None

    data = load(input)

    try:
        validate(data)
    except InvalidDataError as e:
        store(output, invalid(e))
        sys.exit(100)

    if not validate_only:
        store(output, solve(data))

main()
